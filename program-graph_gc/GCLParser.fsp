%{
open ParserTypes
%}

// Declare the tokens (terminal symbols)
%token <int> NUM
%token BOL
%token <string> VAR
%token TIMES DIV MOD PLUS MINUS LPAR RPAR LCB RCB LSB RSB AND 
%token OR NEG EQ NEQ GT GET LT LET TRUE FALSE
%token ELSE ASS SKIP SEMI IF WHILE EOF

// Specification of precedence and associativity of the operators ranking from low to high
%left EQ NEQ GT GET LT LET ELSE
%left PLUS MINUS OR
%left TIMES DIV AND MOD
%right SEMI
%left NEG

// declaring the initial non-terminal symbol
%start start

// spefication of the return type of each of the non-terminal symbols
// where C is starting symbol as specified by the given GCL language
%type <expr> start
//%type <statement> start
//%type <statement> statement
%type <expr> expr
//%type <boolean> boolean

%%

// The first production in "formal" notation is
// start -> S
// here written as:
start: statement EOF             { $1 }

//The grammar for the expression (a) type written in the fslexyacc format
expr:
  | expr TIMES expr   { TimesExpr($1,$3) }
  | expr DIV expr     { DivExpr($1,$3) }
  | expr MOD expr     { ModExpr($1,$3) }
  | expr PLUS expr    { PlusExpr($1,$3) }
  | expr MINUS expr   { MinusExpr($1,$3) }
  | PLUS expr               { UPlusExpr($2) }
  | MINUS expr              { UMinusExpr($2) }
  | NUM                           { Num($1) }
  | LPAR expr RPAR          { $2 }
  | VAR							              { Variable($1) }

//The grammar for the boolean (b) type written in the fslexyacc format
boolean:
  | TRUE						  { True }
  | FALSE						  { False }
  //| BOL							  { Bol($1) }
  | boolean AND boolean           { AndExpr($1,$3) }
  | boolean OR boolean            { OrExpr($1,$3) }
  | NEG boolean					          { NegExpr($2) }
  | expr EQ expr      { Equals($1,$3) }
  | expr NEQ expr     { NotEquals($1,$3) }
  | expr GT expr	    { GrThan($1,$3) }
  | expr GET expr     { GrEqThan($1,$3) }
  | expr LT expr	    { LeThan($1,$3) }
  | expr LET expr	    { LeEqThan($1,$3) }
  //| LPAR expr RPAR			        { $2 }

//The grammar for the statement (S) type written in the fslexyacc format
statement:
  | VAR ASS expr SEMI				        { Ass(Variable $1,$3) }
  | VAR LSB expr RSB ASS expr SEMI { ArrayAss(Variable($1), $3, $6) }
  | SKIP						                     	{ Skip }
  | statement statement			              { Stats($1,$2) }
  | IF LPAR boolean RPAR LCB statement RCB ELSE LCB statement RCB		{ IfElseStat($3, $6, $10) }
  | IF LPAR boolean RPAR LCB statement RCB				   	{ IfStat($3, $6) }
  | WHILE LPAR boolean RPAR LCB statement RCB					{ WhileStat($3,$6) }

%%
